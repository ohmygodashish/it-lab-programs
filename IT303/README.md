### Experiment 2: Bit Stuffing
Bit stuffing is a data transmission technique used to ensure proper frame synchronization and prevent confusion between data and control sequences. In data communication, specific bit patterns like "01111110" are used as flag sequences to mark the beginning and end of frames. However, if this same pattern appears in the data portion, it could be mistakenly interpreted as a frame delimiter. To solve this, bit stuffing inserts an extra '0' bit after five consecutive '1's in the data stream. The receiver performs the inverse operation (bit destuffing) by removing these stuffed bits to recover the original data. This technique ensures transparency in data transmission, allowing any binary data to be transmitted without being misinterpreted as control information. The implementation demonstrates the process of scanning input data, counting consecutive ones, inserting stuff bits when needed, and displaying the resulting stuffed frame.

### Experiment 3: Cyclic Redundancy Check (CRC)
Cyclic Redundancy Check is a powerful error-detecting code commonly used in digital networks and storage devices to detect accidental changes to raw data. CRC works by treating the data as a binary polynomial and dividing it by a predetermined generator polynomial (the key). The remainder of this division becomes the CRC checksum that is appended to the original data before transmission. At the receiver end, the same division is performed; if the remainder is zero, no errors are detected. CRC can detect all single-bit errors, most burst errors, and many other error patterns. The implementation demonstrates the modulo-2 division process using XOR operations, showing how to generate the CRC remainder at the sender side and verify data integrity at the receiver side. This technique is widely used in Ethernet, USB, and many other communication protocols due to its effectiveness and efficient implementation in hardware.

### Experiment 4: Stop and Wait Protocol
Stop and Wait is a simple data link layer protocol that provides reliable data transmission between a sender and receiver. In this protocol, the sender transmits one frame and then waits for an acknowledgment (ACK) before sending the next frame. If the ACK is not received within a timeout period, the sender assumes the frame was lost and retransmits it. This protocol handles two types of errors: lost frames and lost acknowledgments. While simple to implement, Stop and Wait has low efficiency, especially for high-latency connections, as only one frame is in transit at any given time. The implementation simulates this protocol with random ACK loss to demonstrate the timeout and retransmission mechanism. This protocol serves as a foundation for understanding more complex reliable protocols and illustrates fundamental concepts like sequencing, acknowledgments, timeouts, and retransmission in reliable data communications.

### Experiment 5: Sliding Window Protocol
Sliding Window Protocol is an improvement over Stop and Wait that allows multiple frames to be in transit simultaneously, significantly improving efficiency. This protocol uses a "window" that defines the range of frame sequence numbers that can be sent without waiting for individual acknowledgments. The sender can transmit multiple frames up to the window size, and the receiver sends cumulative acknowledgments. There are variants like Go-Back-N (where the receiver discards out-of-order frames and requires retransmission from the lost frame) and Selective Repeat (where the receiver buffers out-of-order frames and only requests retransmission of missing frames). The implementation demonstrates the Go-Back-N variant, showing how the window slides forward as acknowledgments are received and how retransmission occurs when frames are lost. This protocol is fundamental to modern data communications and forms the basis of protocols like TCP, balancing reliability with transmission efficiency.

### Experiment 6: Link State Routing Algorithm
Link State Routing is a dynamic routing algorithm used in packet-switched networks to determine the shortest paths between nodes. Unlike distance-vector routing that relies on second-hand information, each router in a link-state network maintains a complete map of the network topology. Routers periodically exchange link-state advertisements (LSAs) containing information about their directly connected links and costs. Using this complete topology information, each router independently applies Dijkstra's shortest path algorithm to compute the optimal routes to all destinations. The implementation demonstrates Dijkstra's algorithm, showing how a router builds its routing table by iteratively finding the shortest paths to all other nodes in the network. Link-state routing protocols like OSPF (Open Shortest Path First) are widely used in modern networks due to their fast convergence, scalability, and ability to calculate optimal paths based on various metrics.

### Experiment 7: Leaky Bucket Algorithm
The Leaky Bucket Algorithm is a traffic shaping technique used to control the rate of data transmission and smooth out bursty traffic in computer networks. It works by analogy to a bucket with a small hole at the bottom - packets arrive at potentially variable rates (filling the bucket), but leave at a constant rate (leaking out). The algorithm has two key parameters: bucket size (maximum number of packets that can be held) and output rate (constant transmission rate). If the arrival rate exceeds the output rate, excess packets are buffered in the bucket; if the bucket overflows, additional packets are dropped. This approach ensures a consistent output rate regardless of input traffic patterns, preventing network congestion. The implementation simulates this process, showing how packets are buffered, transmitted at a constant rate, and dropped when the bucket capacity is exceeded. The Leaky Bucket is commonly used in network traffic management and quality of service (QoS) implementations.

### Experiment 8: IP Packet Forwarding
IP Packet Forwarding is the fundamental process by which routers direct IP packets from source to destination across multiple networks. When a router receives an IP packet, it examines the destination IP address and consults its routing table to determine the best next hop for the packet. The routing table contains entries with destination networks, subnet masks, next-hop addresses, and outgoing interfaces. The router performs a longest-prefix match to find the most specific route for the destination. If no specific route is found, the packet is forwarded to a default route. This process is repeated at each router along the path until the packet reaches its final destination. The implementation demonstrates a simplified version of this process, showing how a routing table is constructed and used to forward packets based on destination addresses. IP forwarding is the cornerstone of internet routing, enabling the global connectivity that defines modern networks.